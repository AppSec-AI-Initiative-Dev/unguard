# DQL Security Queries Documentation

## Overview

This document explains Dynatrace Query Language (DQL) queries used for security vulnerability analysis within the Unguard application environment. DQL is Dynatrace's powerful query language for retrieving and analyzing data from the Grail database.

## Understanding Security Vulnerability Queries

### Core Query Explained

The following DQL query is designed to count open, non-muted security vulnerabilities:

```dql
fetch security.events
| filter dt.system.bucket=="default_securityevents_builtin"
     AND event.provider=="Dynatrace"
     AND event.type=="VULNERABILITY_STATE_REPORT_EVENT"
     AND event.level=="ENTITY"
// filter for the latest snapshot per entity
| dedup {vulnerability.display_id, affected_entity.id}, sort:{timestamp desc}
// filter for open non-muted vulnerabilities
| filter vulnerability.resolution.status=="OPEN"
     AND vulnerability.parent.mute.status!="MUTED"
     AND vulnerability.mute.status!="MUTED"
// count unique vulnerabilities
| summarize {`Open vulnerabilities`=countDistinctExact(vulnerability.display_id)}
```

### Step-by-Step Breakdown

#### 1. Data Source Selection
```dql
fetch security.events
```
- **Purpose**: Retrieves all security events from Dynatrace's security events table
- **Data Source**: The `security.events` table contains all security-related events including vulnerability reports, security findings, and threat detections

#### 2. Initial Filtering
```dql
| filter dt.system.bucket=="default_securityevents_builtin"
     AND event.provider=="Dynatrace"
     AND event.type=="VULNERABILITY_STATE_REPORT_EVENT"
     AND event.level=="ENTITY"
```
- **dt.system.bucket=="default_securityevents_builtin"**: Filters to the default security events bucket, ensuring we're looking at the standard security event stream
- **event.provider=="Dynatrace"**: Limits results to events generated by Dynatrace itself (excludes third-party security tools)
- **event.type=="VULNERABILITY_STATE_REPORT_EVENT"**: Focuses specifically on vulnerability state reports, filtering out other security event types
- **event.level=="ENTITY"**: Retrieves entity-level vulnerability reports (as opposed to process or service-level reports)

#### 3. Deduplication for Latest State
```dql
| dedup {vulnerability.display_id, affected_entity.id}, sort:{timestamp desc}
```
- **Purpose**: Ensures we get only the most recent vulnerability state for each unique vulnerability-entity combination
- **dedup**: Removes duplicate records based on the combination of vulnerability ID and affected entity ID
- **sort:{timestamp desc}**: Sorts by timestamp in descending order, ensuring the latest report is kept for each vulnerability-entity pair
- **Why needed**: Vulnerability states change over time (open → fixed → re-opened), so we only want the current state

#### 4. Status Filtering
```dql
| filter vulnerability.resolution.status=="OPEN"
     AND vulnerability.parent.mute.status!="MUTED"
     AND vulnerability.mute.status!="MUTED"
```
- **vulnerability.resolution.status=="OPEN"**: Only includes vulnerabilities that are currently open (not fixed, dismissed, or resolved)
- **vulnerability.parent.mute.status!="MUTED"**: Excludes vulnerabilities where the parent vulnerability has been muted
- **vulnerability.mute.status!="MUTED"**: Excludes vulnerabilities that have been directly muted
- **Muting**: In Dynatrace, muting allows users to suppress notifications for known vulnerabilities that are accepted risks or false positives

#### 5. Aggregation and Counting
```dql
| summarize {`Open vulnerabilities`=countDistinctExact(vulnerability.display_id)}
```
- **summarize**: Performs aggregation on the filtered dataset
- **countDistinctExact**: Counts unique vulnerability display IDs, ensuring each vulnerability is counted only once even if it affects multiple entities
- **Result**: Returns a single metric showing the total count of unique open vulnerabilities

## Use Cases and Benefits

### Security Monitoring
- **Real-time Visibility**: Provides current count of active security vulnerabilities in your environment
- **Risk Assessment**: Helps prioritize security efforts by quantifying open vulnerabilities
- **Compliance Reporting**: Supports security compliance requirements by tracking vulnerability remediation

### DevSecOps Integration
- **CI/CD Pipeline Integration**: Can be used in automated security gates
- **Dashboard Metrics**: Ideal for security dashboards and executive reporting
- **Alerting**: Can trigger alerts when vulnerability counts exceed thresholds

### Vulnerability Management
- **Trend Analysis**: Track vulnerability counts over time
- **Team Accountability**: Monitor vulnerability remediation progress
- **Risk Prioritization**: Focus on vulnerabilities actively detected in running applications

## Key Advantages of Dynatrace Security Monitoring

### Runtime Context
Unlike static analysis tools, Dynatrace identifies vulnerabilities in:
- **Loaded Libraries**: Only libraries actually loaded in running processes
- **Executed Code Paths**: Functions and methods actively being used
- **Live Applications**: Real-time detection in production environments

This runtime context significantly reduces false positives and helps prioritize vulnerabilities that pose actual risk.

### Davis AI Enhancement
Dynatrace's Davis AI provides:
- **Risk Scoring**: AI-driven risk assessment for each vulnerability
- **Exploitability Analysis**: Determines if exploits are available
- **Function Usage Detection**: Identifies whether vulnerable functions are actually called
- **Impact Assessment**: Evaluates potential business impact

## Related Queries

### Query Variations

#### Count by Severity
```dql
fetch security.events
| filter dt.system.bucket=="default_securityevents_builtin"
     AND event.provider=="Dynatrace"
     AND event.type=="VULNERABILITY_STATE_REPORT_EVENT"
     AND event.level=="ENTITY"
| dedup {vulnerability.display_id, affected_entity.id}, sort:{timestamp desc}
| filter vulnerability.resolution.status=="OPEN"
     AND vulnerability.parent.mute.status!="MUTED"
     AND vulnerability.mute.status!="MUTED"
| summarize {count=countDistinctExact(vulnerability.display_id)}, by:{vulnerability.risk.level}
```

#### Vulnerabilities by Entity
```dql
fetch security.events
| filter dt.system.bucket=="default_securityevents_builtin"
     AND event.provider=="Dynatrace"
     AND event.type=="VULNERABILITY_STATE_REPORT_EVENT"
     AND event.level=="ENTITY"
| dedup {vulnerability.display_id, affected_entity.id}, sort:{timestamp desc}
| filter vulnerability.resolution.status=="OPEN"
     AND vulnerability.parent.mute.status!="MUTED"
     AND vulnerability.mute.status!="MUTED"
| summarize {vulnerabilities=countDistinctExact(vulnerability.display_id)}, by:{affected_entity.name}
```

## Best Practices

### Query Performance
- Use specific filters early in the query to reduce data processing
- Leverage time ranges when analyzing historical data
- Consider using sampling for large datasets in exploratory analysis

### Security Analysis
- Combine with Davis AI assessments for comprehensive risk evaluation
- Cross-reference with CVSS scores and CVE databases
- Monitor trends over time rather than just point-in-time counts
- Focus on vulnerabilities in actively used code paths

### Monitoring and Alerting
- Set up regular monitoring of vulnerability counts
- Create alerts for significant increases in open vulnerabilities
- Track vulnerability age and remediation time metrics
- Monitor muted vulnerabilities to ensure they remain acceptable risks

## Integration with Unguard

This query is particularly valuable for the Unguard application because:

1. **Known Vulnerabilities**: Unguard intentionally contains multiple security vulnerabilities
2. **Multi-language Environment**: With services in Java, .NET, PHP, Node.js, Python, and Go, comprehensive vulnerability scanning is crucial
3. **Dependency Management**: Helps track vulnerabilities in the numerous third-party libraries used across services
4. **Security Demonstrations**: Provides metrics for security training and demonstration purposes

The query helps security teams and developers understand the actual risk posture of the Unguard environment by focusing on vulnerabilities that are present in running code rather than theoretical risks.